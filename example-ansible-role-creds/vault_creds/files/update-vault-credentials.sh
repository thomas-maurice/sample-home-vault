#!/bin/bash

# The following variables need to be populated
# VAULT_ADDR
# VAULT_APPROLE_PATH
# VAULT_APPROLE_ROLE_ID
# VAULT_APPROLE_SECRET_ID

if [ -z "${VAULT_ADDR}" ] || [ -z "${VAULT_APPROLE_PATH}" ] || [ -z "${VAULT_APPROLE_ROLE_ID}" ] || [ -z "${VAULT_APPROLE_SECRET_ID}" ]; then
    eval "$(load-vault-credentials.sh)"
fi;

_services="ssh.service traefik.service nginx.service rsyslog.service"
_needs_restart=0
_base_certs_dir=/srv/certs/certs
_base_keys_dir=/srv/certs/keys

function _log() {
    logger --id="$$" "${@}"
    echo "${@}"
}

# returns 0 if the certificate expires after N seconds, 1 otherwise
function _cert_expires_before() {
    local certfile
    local seconds
    certfile=$1
    seconds=$2

    if [ -f "${certfile}" ]; then
        expiry=$(openssl x509 -dates -noout < "${certfile}" | grep notAfter | cut -f2 -d= | date -f - --utc +"%s")
        if [[ $(( expiry - $(date "+%s"))) -lt ${seconds} ]]; then
            return 1
        fi;
        return 0
    fi;
    return 1
}

# gets the timestamp of expiration of a given ssh cert
function _ssh_cert_expiry() {
    ssh-keygen -Lf "${1}" | grep Valid: | awk '{ print $5 }' | date --utc -f - +"%s"
}

# gets the hex serial number of an ssh cert
function _ssh_cert_serial() {
    local serial
    serial=$(ssh-keygen -Lf "${1}" | grep Serial: | awk '{ print $2}')
    python -c "print('{:x}'.format(${serial}))"
}

# returns 0 if the cert is valid before n seconds, 1 otherwise
function _ssh_cert_expires() {
    local certfile
    local seconds
    certfile=$1
    seconds=$2

    expiry=$(_ssh_cert_expiry "$1")
    if [[ $(( expiry - $(date "+%s"))) -lt ${seconds} ]]; then
        return 1
    fi;
    return 0
}

function _cert_match_key() {
    local certfile
    local keyfile
    certfile=$1
    keyfile=$2

    if ! [ -f "${certfile}" ] || ! [ -f "${keyfile}" ]; then echo "missing key or cert file"; return 1; fi;

    crtSHA="$(openssl x509 -pubkey -noout -in "${certfile}" | sha256sum | awk '{ print $1 }' | cut -c -10)"
    keySHA="$(openssl pkey -pubout -in "${keyfile}" | sha256sum | awk '{ print $1 }' | cut -c -10)"

    if [ "${crtSHA}" != "${keySHA}" ]; then
        _log "mismatch detected between private key (${keySHA}) and cert (${crtSHA}), forcing renew"
        return 1
    else
        _log "private key matches host certificate (${keySHA})"
        return 0
    fi;
}

function _restart_affected_services() {
    for svc in ${_services}; do
        if systemctl list-unit-files --state=enabled | grep -q "${svc}"; then
        _log "restarting service ${svc} because new certs were issued"
            systemctl restart "${svc}"
        fi;
    done;
}

function _vault_login() {
    local tkn
    tkn=$(vault write -format=json "${VAULT_APPROLE_PATH}"/login role_id="${VAULT_APPROLE_ROLE_ID}" secret_id="${VAULT_APPROLE_SECRET_ID}" | jq -r .auth.client_token)
    
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then
        _log "could not log into vault"
        exit 1
    fi;
    if [ -z "${tkn}" ]; then
        _log "could not log into vault"
        exit 1
    fi;
    export VAULT_TOKEN=${tkn}
    echo "successfully managed to log into vault"
}

function _ensure_dependencies() {
    for needed_binary in \
        vault \
        jq; do
        if ! which "${needed_binary}" >/dev/null 2>&1; then
            _log "${needed_binary} is not installed"
            exit 1
        fi
    done;
}

# This function is going to check the certificates that should be installed.
# these are not the vault CA certs, they are arbitrary certs, like the ones
# generated by letsencrypt for example
function _vault_rotate_certificates() {
    local tmpDir
    tmpDir=$(mktemp -d)
    
    # shellcheck disable=SC2013
    for certificate in $(cat /etc/default/vault_certificates); do 
        local renewNeeded
        renewNeeded=0
        local resFile
        resFile="${tmpDir}/${certificate}.json"

        local certfile
        certfile=${_base_certs_dir}/${certificate}.crt
        local keyfile
        keyfile=${_base_keys_dir}/${certificate}.key

        if ! _cert_expires_before "${certfile}" $(( 3600 * 24 * 3)); then # check for renew 72 before
            _log "certificate ${certificate} expires soon or does not exist, needs renewing"
            renewNeeded=1
        fi;

        if ! _cert_match_key "${certfile}" "${keyfile}"; then
            _log "certificate ${certificate} does not match the key does not exist, needs renewing"
            renewNeeded=1
        fi;

        if [ ${renewNeeded} -eq 0 ]; then _log "no need to renew certificate ${certificate}"; continue; fi;

        _log "updating certificate ${certificate}"

        vault kv get -format=json "prod/kv/certificates/${certificate}" > "${resFile}"
        jq -r .data.data.certificate < "${resFile}" > "${certfile}"
        jq -r .data.data.key < "${resFile}" > "${keyfile}"

        chown root:vault-users "${certfile}" "${keyfile}"
        chmod 0640 "${certfile}" "${keyfile}"

        _needs_restart=1
    done;
    
    rm -rf "${tmpDir}"
}

# rotates the ssh certificates
function _vault_rotate_ssh_certificates() {
    local tmpDir
    tmpDir=$(mktemp -d)
    
    # shellcheck disable=SC2045
    for sshkey in $(ls /etc/ssh/*host*key); do 
        local renewNeeded
        renewNeeded=0
        local resFile
        resFile="${tmpDir}/$(basename "${sshkey}").json"

        local certfile
        certfile=${sshkey}-cert.pub
        local keyfile
        keyfile=${sshkey}.pub

        if ! _ssh_cert_expires "${certfile}" $(( 3600 * 24 * 3)); then # check for renew 72 before
            _log "ssh certificate ${keyfile} expires soon or does not exist, needs renewing"
            renewNeeded=1
        fi;

        if [ ${renewNeeded} -eq 0 ]; then _log "no need to renew ssh certificate ${keyfile}"; continue; fi;

        _log "updating ssh certificate ${keyfile}"

        vault write -format=json prod/ssh/sign/host cert_type=host public_key="@${keyfile}" > "${resFile}"
        jq -r .data.signed_key < "${resFile}" | tr -d "\n" > "${certfile}"

        chown root:root "${certfile}" "${keyfile}"
        chmod 0640 "${certfile}"

        _log "renewed ssh cert ${keyfile}"

        _needs_restart=1
    done;
    
    rm -rf "${tmpDir}"
}

function _vault_regen_certificate() {
    local tmpDir
    tmpDir=$(mktemp -d)
    res="${tmpDir}"/result.json

    local renewNeeded
    renewNeeded=0

    if [ -f /srv/certs/certs/host.crt ] && [ -f /srv/certs/keys/host.key ]; then
        expiry=$(openssl x509 -dates -noout < /srv/certs/certs/host.crt | grep notAfter | cut -f2 -d= | date -f - --utc +"%s")
        if [[ $(( expiry - $(date "+%s"))) -lt $(( 6600 * 24 )) ]]; then
            _log "need to renew host cert -- soon expired"
            renewNeeded=1
        else
            _log "no need to renew host cert for expiry"
        fi;
    else
        _log "no certificates found, generating"
        renewNeeded=1
    fi;

    local keySHA
    local crtSHA

    crtSHA="$(openssl x509 -pubkey -noout -in /srv/certs/certs/host.crt | sha256sum | awk '{ print $1 }' | cut -c -10)"
    keySHA="$(openssl pkey -pubout -in /srv/certs/keys/host.key | sha256sum | awk '{ print $1 }' | cut -c -10)"

    if [ "${crtSHA}" != "${keySHA}" ]; then
        _log "Mismatch detected between private key (${keySHA}) and cert (${crtSHA}), forcing renew"
        renewNeeded=1
    else
        _log "private key matches host certificate (${keySHA})"
    fi;

    if [ ${renewNeeded} -eq 0 ]; then _log "no need to renew certificates"; return 0; fi;

    _log "creating a new certificate"

    vault write -format=json prod/pki/pki_intermediate/issue/server common_name="$(hostname -f)" ttl="$(( 24 * 3600 * 7))" > "${res}"
    jq -r .data.certificate < "${res}" > /srv/certs/certs/host.crt
    jq -r .data.issuing_ca < "${res}" >> /srv/certs/certs/host.crt
    jq -r .data.private_key < "${res}" > /srv/certs/keys/host.key

    chown root:vault-users /srv/certs/certs/host.crt /srv/certs/keys/host.key
    chmod 0640 /srv/certs/certs/host.crt /srv/certs/keys/host.key

    _needs_restart=1

    rm -rf "${tmpDir}"
}



_ensure_dependencies
_vault_login
_vault_regen_certificate
_vault_rotate_certificates
_vault_rotate_ssh_certificates

if [ ${_needs_restart} -eq 1 ]; then
    _log "service restrarts are needed"
    _restart_affected_services
fi;